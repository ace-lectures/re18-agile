= Reconciling Requirements and Continuous Integration in an Agile Context
Sebastien Mosser <https://github.com/mosser[@mosser]>; Jean-Michel Bruel <https://github.com/jmbruel[@jmbruel]>

// Stuff for look & feel --------
:imagesdir: images
ifndef::env-github[:icons: font]
ifdef::env-github,env-browser[]
:toc: macro
:toclevels: 1
endif::[]
ifdef::env-github[]
:branch: master
:status:
:outfilesuffix: .adoc
:!toc-title:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

// Variables ---------------------
:re2018url: http://www.re18.org/
:re2018: {re2018url}[RE'2018]
:re2018tuto: http://www.re18.org/tutorials.html#T02
:docker: https://docs.docker.com/[Docker]
:gherkin: http://cukes.info/gherkin.html[Gherkin]
:maven: https://maven.apache.org/[Maven]
:java: https://java.com/en/download/[Java]
:repo: https://github.com/mosser/agile-tutorial

== Context

This tutorial is part of the {re2018} conference (see {re2018tuto}).
Do not hesitate to contact the authors to contribute or give feedback:
Sebastien Mosser <https://github.com/mosser[@mosser]> & Jean-Michel Bruel <https://github.com/jmbruel[@jmbruel]>.

== Content

This tutorial aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. Revisiting requirements elicitation and bridging the gap between traditional requirements engineering and modern software development (highly based on continuous integration and tests), this tutorial will demonstrate how to operationalize a fully-fledged tool chain going from user stories to automated acceptance testing using open-source tools. This is applicable to industrial practitioners as we will rely on state of the art tools, and link agile requirements to formal requirement engineering methods. We will first focus on the notion of user stories and epics to express user’s requirements, and how to evaluate such requirements based on “definition of ready” and “definition of done” acceptance criteria. We will then demonstrate how such requirements can be tracked in a project management tool, and linked to source code development. At the source code level, we will demonstrate how the stories and the associated acceptance scenarios can be modeled using the {gherkin} language, and linked to classical unit tests to automate their validation. Finally, a continuous integration environment will be deployed using Docker to link together the different tools and offer an automated pipeline for software developers, bridging the gap between requirements and code development.

== Prerequisites

Please read the Prerequisites page to install the necessary software on your computer before the tutorial.

== Tutorial


* Step #0 (optional): {repo}/blob/master/steps/step0.adoc[Setting up a Java project]
* Step #1: {repo}/blob/master/steps/step1.adoc[Creating the product backlog]
* Step #2: {repo}/blob/master/steps/step1.adoc[Starting the first sprint]








=== Step #3: Starting a first Sprint

We are not going to start from scratch and we will consider that the initial sprint (often call "Sprint 0") has been done and that the basic code, the coding framework and the testing framework is in place.

. Download it here: TODO.
. Start developping the 1st story of your backlog
* Find a way to automatically validate the acceptance criteria
* Rince and repeat
+
.Feedback
[TIP]
====
* What do you think about developpement time ?
* What is the role of automated acceptation ?
* Over-engineering vs emerging architecture ?
* How to validate the backlog ?
* Limitations on the acceptance tests in Cucumber?
* How to test UI ?
====

=== Step #4: Continuous Deployment

In this step you will deploy your app as a {docker} image that can be used in a shell.

.Feedback
[TIP]
====
What are the benefits of such packaging ?
Why an image and not code or exe ?
====

. Set a continuous integration pipeline.
. Note that we use {Docker} to ease and accelerate the process, but this is not mandatory.
* Set up a Git server, a Jenkins, an artifactory
* When you commit, tests are laounched on the CI server, and build the new version on the artifactory repo.
+
.Feedback
[TIP]
====
What do you thonk of this process ?
Heavy ? Avantages ? Critical projects size ?
====
+
. Continuous deployment: modify the jenkins so that it generates the docker-ready image to go.
+
WARNING: As jenkins is already in Docker, you are doing docker in docker!
+
.Feedback
[TIP]
====
TODO (du commit au deployment ?)
====

== References and links

* Kata:
** https://codingdojo.org/kata/PokerHands/
** Poker combinations and ranking: https://www.espacejeux.com/en/poker/combinations
+
.Poker combinations (source: https://t.co/L5H2RvSkz8)
image::hands.jpg[width=50%]

[[backlogtools]]
* Backlog tools (examples)
** https://easybacklog.com/
** https://trello.com/
